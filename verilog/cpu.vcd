$date
	Thu Dec 25 13:11:16 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module test_cpu $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module DUT $end
$var wire 1 ! clk $end
$var wire 1 # pc_load_en $end
$var wire 1 " reset $end
$var wire 32 $ rs2_val [31:0] $end
$var wire 4 % rs2 [3:0] $end
$var wire 32 & rs1_val [31:0] $end
$var wire 4 ' rs1 [3:0] $end
$var wire 1 ( reg_write_en $end
$var wire 32 ) rd_value [31:0] $end
$var wire 4 * rd [3:0] $end
$var wire 32 + pc_value [31:0] $end
$var wire 32 , pc_next [31:0] $end
$var wire 4 - opcode [3:0] $end
$var wire 1 . mem_write_en $end
$var wire 1 / mem_read_en $end
$var wire 32 0 mem_data_out [31:0] $end
$var wire 32 1 mem_data_in [31:0] $end
$var wire 32 2 mem_addr [31:0] $end
$var wire 32 3 instruction [31:0] $end
$var wire 16 4 imm [15:0] $end
$var wire 1 5 halt $end
$var wire 16 6 branch_target [15:0] $end
$var wire 1 7 branch_taken $end
$scope module decoder $end
$var wire 4 8 rs2 [3:0] $end
$var wire 4 9 rs1 [3:0] $end
$var wire 4 : rd [3:0] $end
$var wire 4 ; opcode [3:0] $end
$var wire 32 < instruction [31:0] $end
$var wire 16 = imm [15:0] $end
$upscope $end
$scope module dmem $end
$var wire 1 ! clk $end
$var wire 32 > write_data [31:0] $end
$var wire 1 . mem_write $end
$var wire 1 / mem_read $end
$var wire 32 ? address [31:0] $end
$var reg 32 @ read_data [31:0] $end
$upscope $end
$scope module exec $end
$var wire 16 A imm [15:0] $end
$var wire 32 B mem_data_in [31:0] $end
$var wire 4 C opcode [3:0] $end
$var wire 16 D pc [15:0] $end
$var wire 4 E rd [3:0] $end
$var wire 32 F rs2_val [31:0] $end
$var wire 32 G rs1_val [31:0] $end
$var reg 1 7 branch_taken $end
$var reg 16 H branch_target [15:0] $end
$var reg 1 5 halt $end
$var reg 32 I mem_addr [31:0] $end
$var reg 32 J mem_data_out [31:0] $end
$var reg 1 / mem_read_en $end
$var reg 1 . mem_write_en $end
$var reg 32 K rd_value [31:0] $end
$var reg 1 ( reg_write_en $end
$upscope $end
$scope module fetch $end
$var wire 1 ! clk $end
$var wire 1 # load_en $end
$var wire 32 L pc_next [31:0] $end
$var wire 1 " reset $end
$var wire 32 M current_pc [31:0] $end
$var wire 32 N current_instruction [31:0] $end
$scope module inst_mem $end
$var wire 32 O instruction [31:0] $end
$var wire 32 P address [31:0] $end
$upscope $end
$scope module program_counter $end
$var wire 1 ! clk $end
$var wire 32 Q d [31:0] $end
$var wire 1 # load_en $end
$var wire 1 " reset $end
$var reg 32 R q [31:0] $end
$upscope $end
$upscope $end
$scope module regfile $end
$var wire 1 ! clk $end
$var wire 4 S rd [3:0] $end
$var wire 1 ( reg_write $end
$var wire 4 T rs1 [3:0] $end
$var wire 32 U rs1_data [31:0] $end
$var wire 4 V rs2 [3:0] $end
$var wire 32 W rs2_data [31:0] $end
$var wire 32 X write_data [31:0] $end
$var integer 32 Y i [31:0] $end
$scope task display_all $end
$var integer 32 Z j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx Z
b10000 Y
b1 X
b0 W
b0 V
b0 U
b0 T
b11 S
b0 R
b1 Q
b0 P
b100011000000000000000000000001 O
b100011000000000000000000000001 N
b0 M
b1 L
b1 K
b0 J
b0 I
b0 H
b0 G
b0 F
b11 E
b0 D
b10 C
b0 B
b1 A
b0 @
b0 ?
b0 >
b1 =
b100011000000000000000000000001 <
b10 ;
b11 :
b0 9
b0 8
07
b0 6
05
b1 4
b100011000000000000000000000001 3
b0 2
b0 1
b0 0
0/
0.
b10 -
b1 ,
b0 +
b11 *
b1 )
1(
b0 '
b0 &
b0 %
b0 $
0#
1"
0!
$end
#5000
1!
#10000
0!
0"
#15000
1(
b10 )
b10 K
b10 X
b10 ,
b10 L
b10 Q
b10 4
b10 =
b10 A
b1000 *
b1000 :
b1000 E
b1000 S
b1 D
b101000000000000000000000000010 3
b101000000000000000000000000010 <
b101000000000000000000000000010 N
b101000000000000000000000000010 O
b1 +
b1 M
b1 P
b1 R
1!
#20000
0!
#25000
1(
b11 )
b11 K
b11 X
b11 ,
b11 L
b11 Q
b11 4
b11 =
b11 A
b1010 *
b1010 :
b1010 E
b1010 S
b10 D
b101010000000000000000000000011 3
b101010000000000000000000000011 <
b101010000000000000000000000011 N
b101010000000000000000000000011 O
b10 +
b10 M
b10 P
b10 R
1!
#30000
0!
#35000
15
0(
b0 )
b0 K
b0 X
b100 ,
b100 L
b100 Q
b100 4
b100 =
b100 A
b0 *
b0 :
b0 E
b0 S
b110 -
b110 ;
b110 C
b11 D
b1100000000000000000000000000100 3
b1100000000000000000000000000100 <
b1100000000000000000000000000100 N
b1100000000000000000000000000100 O
b11 +
b11 M
b11 P
b11 R
1!
#40000
0!
#45000
05
b101 ,
b101 L
b101 Q
bx 4
bx =
bx A
bx $
bx F
bx W
bx %
bx 8
bx V
bx &
bx G
bx U
bx '
bx 9
bx T
bx *
bx :
bx E
bx S
bx -
bx ;
bx C
b100 D
bx 3
bx <
bx N
bx O
b100 +
b100 M
b100 P
b100 R
b10000 Z
1!
